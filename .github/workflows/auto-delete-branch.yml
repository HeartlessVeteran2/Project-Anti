name: Auto Delete Branch

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: write

jobs:
  delete-branch:
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.merged == true &&
      github.event.pull_request.head.repo.full_name == github.event.pull_request.base.repo.full_name
    timeout-minutes: 5
    
    steps:
      - name: Delete merged branch
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const branchName = context.payload.pull_request.head.ref;
            const prNumber = context.payload.pull_request.number;
            const prTitle = context.payload.pull_request.title;
            
            // Protected branches that should never be deleted
            const protectedBranches = [
              'main', 
              'master', 
              'develop', 
              'dev', 
              'staging', 
              'production', 
              'release',
              'hotfix'
            ];
            
            // Check if branch is protected
            if (protectedBranches.includes(branchName)) {
              console.log(`‚ö†Ô∏è Skipping deletion of protected branch: ${branchName}`);
              return;
            }
            
            // Check if branch name suggests it's a release branch
            if (branchName.match(/^(release|hotfix)\/.*$/)) {
              console.log(`‚ö†Ô∏è Skipping deletion of release/hotfix branch: ${branchName}`);
              return;
            }
            
            // Check if it's from a fork (already handled by the if condition above, but double-check)
            if (context.payload.pull_request.head.repo.full_name !== context.payload.pull_request.base.repo.full_name) {
              console.log(`‚ö†Ô∏è Skipping deletion of fork branch: ${branchName}`);
              return;
            }
            
            try {
              // Attempt to delete the branch
              await github.rest.git.deleteRef({
                owner,
                repo,
                ref: `heads/${branchName}`
              });
              
              console.log(`‚úÖ Successfully deleted branch: ${branchName}`);
              
              // Add a comment to the PR confirming deletion
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: `üßπ **Branch Cleanup**\n\nAutomatically deleted branch \`${branchName}\` after successful merge.\n\n_This action was performed by the auto-delete-branch workflow._`
              });
              
            } catch (error) {
              console.log(`‚ùå Failed to delete branch ${branchName}: ${error.message}`);
              
              // Only comment on error if it's not a "not found" error (branch might already be deleted)
              if (!error.message.includes('Not Found') && !error.message.includes('Reference does not exist')) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `‚ö†Ô∏è **Branch Cleanup Failed**\n\nCould not automatically delete branch \`${branchName}\`:\n\n\`\`\`\n${error.message}\n\`\`\`\n\nYou may need to delete this branch manually.\n\n_This message was generated by the auto-delete-branch workflow._`
                });
              } else {
                console.log(`‚ÑπÔ∏è Branch ${branchName} was already deleted or does not exist`);
              }
            }

  cleanup-stale-branches:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    timeout-minutes: 10
    
    steps:
      - name: Cleanup related stale branches
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const mergedBranch = context.payload.pull_request.head.ref;
            const prNumber = context.payload.pull_request.number;
            
            console.log(`üîç Looking for stale branches related to merged branch: ${mergedBranch}`);
            
            try {
              // Get all branches
              const branches = await github.rest.repos.listBranches({
                owner,
                repo,
                per_page: 100
              });
              
              const protectedBranches = ['main', 'master', 'develop', 'dev', 'staging', 'production', 'release'];
              let deletedBranches = [];
              
              for (const branch of branches.data) {
                const branchName = branch.name;
                
                // Skip protected branches
                if (protectedBranches.includes(branchName)) {
                  continue;
                }
                
                // Skip the main merged branch (should already be handled by the first job)
                if (branchName === mergedBranch) {
                  continue;
                }
                
                // Look for branches that might be related (same prefix, similar naming)
                const isRelated = (
                  branchName.startsWith(`${mergedBranch}-`) ||
                  branchName.startsWith(`${mergedBranch}_`) ||
                  (mergedBranch.includes('/') && branchName.startsWith(mergedBranch.split('/')[0] + '/')) ||
                  branchName.includes(`pr-${prNumber}`) ||
                  branchName.includes(`fix-${prNumber}`)
                );
                
                if (isRelated) {
                  try {
                    // Check if branch has any open PRs
                    const prs = await github.rest.pulls.list({
                      owner,
                      repo,
                      head: `${owner}:${branchName}`,
                      state: 'open'
                    });
                    
                    if (prs.data.length === 0) {
                      // Check if branch is significantly behind or ahead
                      const comparison = await github.rest.repos.compareCommits({
                        owner,
                        repo,
                        base: 'main',
                        head: branchName
                      });
                      
                      // If branch is only behind (no unique commits), it's safe to delete
                      if (comparison.data.ahead_by === 0) {
                        await github.rest.git.deleteRef({
                          owner,
                          repo,
                          ref: `heads/${branchName}`
                        });
                        
                        deletedBranches.push(branchName);
                        console.log(`‚úÖ Deleted related stale branch: ${branchName}`);
                      }
                    }
                  } catch (error) {
                    console.log(`‚ö†Ô∏è Could not process branch ${branchName}: ${error.message}`);
                  }
                }
              }
              
              // Comment on PR if we deleted additional branches
              if (deletedBranches.length > 0) {
                const branchList = deletedBranches.map(b => `- \`${b}\``).join('\n');
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `üßπ **Additional Branch Cleanup**\n\nAlso deleted ${deletedBranches.length} related stale branch(es):\n\n${branchList}\n\n_These branches appeared to be related to this PR and had no unique commits._`
                });
              }
              
            } catch (error) {
              console.log(`‚ùå Error during stale branch cleanup: ${error.message}`);
            }